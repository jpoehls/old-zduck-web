---
layout: post
title: .NET Migrations Demo
---
<style type="text/css"><br /><br /><br /><br /><br />a img { margin-left: -40px; }</style>  <p>Here’s my attempt at demonstrating how great migrations are through a simple Hello World demo. Enjoy.</p>  <p>I’m going to show you how migrations can be used with a Hello World app that uses a database.</p>  <p>Oh yeah, if you haven't already, you'll want to read my first post about .NET Migrations (a.k.a. <a href="http://zduck.blogspot.com/2008/04/ruby-on-rails-migrations-for-net.html">Ruby on Rails Migrations for .NET</a>).</p>  <h2>The Demo</h2>  <ol>   <li>I’ve created the directory structure for my app. 
<a href="http://lh5.ggpht.com/jpoehls/SBHeNPhLgCI/AAAAAAAABpM/pwW1phf49AQ/1%5B7%5D.png"><img height="159" alt="1" src="http://lh5.ggpht.com/jpoehls/SBHcsPhLflI/AAAAAAAABpU/MqamNtJBlws/1_thumb%5B5%5D.png" width="400" /></a>      
</li>    <li>In the ‘db’ folder I’ve placed the DotNetMigrations executable along with a config file to store some connection strings in. Note that this config file is not required, you can always pass in your connection string to db.exe as an argument. The config file just means less typing for me. 
<a href="http://lh6.ggpht.com/jpoehls/SBHcsfhLfmI/AAAAAAAABpY/tHoHVArOl_Q/2%5B8%5D.png"><img height="110" alt="2" src="http://lh4.ggpht.com/jpoehls/SBHcs_hLfnI/AAAAAAAABpc/EBy_pUEuT_M/2_thumb%5B6%5D.png" width="400" /></a>      
</li>    <li>My config file has 2 connection strings, one for DEV and one for TEST: 
<a href="http://lh6.ggpht.com/jpoehls/SBHctfhLfoI/AAAAAAAABpg/vjQhiQkJBgY/3%5B7%5D.png"><img height="130" alt="3" src="http://lh3.ggpht.com/jpoehls/SBHctvhLfpI/AAAAAAAABpk/4Tv9Ou-Valc/3_thumb%5B5%5D.png" width="400" /></a>      
</li>    <li>Notice you have to already have created your database on the server. Creating databases it outside the scope of migrations. Migrations only care about the schema (tables, sprocs, functions, users, etc) <i>inside</i> an existing database.      
</li>    <li>My Hello World app needs a new “Languages” table to hold every country’s language. Lets create a migration to make this change. Start by running db.exe from the command line, notice how it will give you examples for how to call each available command: 
<a href="http://lh5.ggpht.com/jpoehls/SBHcuPhLfqI/AAAAAAAABpo/K6-CjFwjGfU/4%5B5%5D.png"><img height="242" alt="4" src="http://lh6.ggpht.com/jpoehls/SBHcufhLfrI/AAAAAAAABps/AZ7jSeMcZ5M/4_thumb%5B3%5D.png" width="400" /></a>      
</li>    <li>We want to create a new migration so we’re interested in the ‘generate’ command. Let’s execute it:     
<b>db generate create_languages_table 
<a href="http://lh3.ggpht.com/jpoehls/SBHcuvhLfsI/AAAAAAAABpw/92kJ6IA_Tq0/5%5B5%5D.png"><img height="48" alt="5" src="http://lh4.ggpht.com/jpoehls/SBHcu_hLftI/AAAAAAAABp0/uXlqcXn9B4I/5_thumb%5B3%5D.png" width="400" /></a>        
</b></li>    <li>Great! It says it created my migration. Let’s see where it put it: 
<a href="http://lh5.ggpht.com/jpoehls/SBHcvPhLfuI/AAAAAAAABp4/Dx5O71QaUnE/6%5B6%5D.png"><img height="105" alt="6" src="http://lh3.ggpht.com/jpoehls/SBHcvvhLfvI/AAAAAAAABp8/FK1ZpaEJJlU/6_thumb%5B4%5D.png" width="400" /></a>      
</li>    <li>I can see here it created a /migrate folder and put my migration in a .sql file under it. Notice how it automatically gave the file a sequential number. This is how DotNetMigrations knows which order to apply your migrations in when you run them.     
</li>    <li>Ok. So the migration it generated is just a blank template. Let’s open it up and see what we get: 
<a href="http://lh4.ggpht.com/jpoehls/SBHcv_hLfwI/AAAAAAAABqA/MGfMzJFDfWA/7%5B5%5D.png"><img height="278" alt="7" src="http://lh6.ggpht.com/jpoehls/SBHcwfhLfxI/AAAAAAAABqE/QyONM3pACQM/7_thumb%5B3%5D.png" width="400" /></a>      
</li>    <li>This is the template for our migration. Every migration has a SETUP step and a TEARDOWN step. The idea here is that for every change (migration) we make to the database, we need a way to undo, or roll it back, that’s the Teardown.     
</li>    <li>Now let’s add our change. Remember, this really is just a SQL script. You can add any kind of T-SQL here that you want: 
<a href="http://lh3.ggpht.com/jpoehls/SBHcwvhLfyI/AAAAAAAABqI/q8V4WmdwVNc/8%5B5%5D.png"><img height="407" alt="8" src="http://lh5.ggpht.com/jpoehls/SBHcxPhLfzI/AAAAAAAABqM/LyvmF8OZeMY/8_thumb%5B3%5D.png" width="400" /></a>      
</li>    <li>Kool. So here we’ve said we want to create a new Languages table and insert some rows of data. We’ve also told our Teardown how to undo this Setup by dropping the table.     
</li>    <li>A quick way to test this script would be to run it in SQL Studio against your database. If it works correctly you should see no change whatsoever in your database. Think about it, your SETUP will run, make the change, then your TEARDOWN will run and undo that change. The result should be the same as what you started with.     
</li>    <li>Now let’s use DotNetMigrations to migrate our DEV database to this migration version 1 we’ve created. This is as easy as executing <b>db migrate dev</b>. Since we didn’t specify a version to migrate to, it is assumed we want to migrate to the most recent version available (in this case version 1). Remember, <b>dev</b>, is what we named our connection string in the config file that hits the DEV database. 
<a href="http://lh6.ggpht.com/jpoehls/SBHcxfhLf0I/AAAAAAAABqQ/fDb7T16sJbA/9%5B5%5D.png"><img height="80" alt="9" src="http://lh3.ggpht.com/jpoehls/SBHcxvhLf1I/AAAAAAAABqU/1JyhR_XOwh0/9_thumb%5B3%5D.png" width="400" /></a>      
</li>    <li>Sweet! So we see here that before the database was migrated it was at version 0 and after the migration it is at version 1. Now if we look at our database we see we have not only the Languages table we told it to add, but we also have a new <b>schema_info</b> table… 
<a href="http://lh5.ggpht.com/jpoehls/SBHcyPhLf2I/AAAAAAAABqY/viKScYBhenw/10%5B6%5D.png"><img height="213" alt="10" src="http://lh6.ggpht.com/jpoehls/SBHcyfhLf3I/AAAAAAAABqc/VRUb1DCE6Ho/10_thumb%5B4%5D.png" width="400" /></a>      
</li>    <li>This table is created and maintained automagically by DotNetMigrations. It only has 1 row and 1 column, “version”. And DotNetMigrations uses this to track what version of the schema the database contains. This is how it knows which migration scripts need to be ran to migrate the database to and from any version specified.     
</li>    <li>That was simple enough. So now I discover that that Languages table should also have a column to store the Difficulty of the language. Lets create a new migration for that: 
<a href="http://lh4.ggpht.com/jpoehls/SBHcy_hLf4I/AAAAAAAABqg/YYcc1iWF5-k/11%5B6%5D.png"><img height="291" alt="11" src="http://lh5.ggpht.com/jpoehls/SBHczPhLf5I/AAAAAAAABqk/p117W-OH580/11_thumb%5B4%5D.png" width="400" /></a>      
</li>    <li>Now let’s migrate our database: 
<a href="http://lh6.ggpht.com/jpoehls/SBHczfhLf6I/AAAAAAAABqo/IWz9QFAXNWQ/12%5B5%5D.png"><img height="90" alt="12" src="http://lh4.ggpht.com/jpoehls/SBHcz_hLf7I/AAAAAAAABqs/DENcCysLSKw/12_thumb%5B3%5D.png" width="400" /></a>      
</li>    <li>Awesome. That was easy. But wait, now I need to rollback to version 1 for some reason… 
<a href="http://lh5.ggpht.com/jpoehls/SBHc0PhLf8I/AAAAAAAABqw/A8QZKHhsxdc/13%5B5%5D.png"><img height="124" alt="13" src="http://lh3.ggpht.com/jpoehls/SBHc0vhLf9I/AAAAAAAABq0/OJNocRcs8ws/13_thumb%5B3%5D.png" width="400" /></a>      
</li>    <li>It’s just that easy. We can roll all the way back to version 0 if we want: <b>db migrate 0 dev. </b>This will perform the teardown script for version 1, which brings us back to version 0.      
</li>    <li>Then migrate all the way up to the latest version (2): <b>db migrate dev</b>. This executes the setup scripts for versions 1 and 2 in order.      
</li>    <li>You can see the current version your database’s schema at anytime by running the <strong>version</strong> command: 
<a href="http://lh4.ggpht.com/jpoehls/SBHc0_hLf-I/AAAAAAAABq4/-T9kDFt5dI4/14%5B5%5D.png"><img height="148" alt="14" src="http://lh5.ggpht.com/jpoehls/SBHc1PhLf_I/AAAAAAAABq8/C6qHOl3tSvA/14_thumb%5B3%5D.png" width="400" /></a>      
</li>    <li>This tells you both the current version of your database’s schema as well as the latest migration script you have. We can see here that my DEV database is at version 1 but I have a migration version 2 available to run.     
</li>    <li>One last thing, my Hello World app is ready to go to QA. Let’s bring the TEST database up to speed: 
<a href="http://lh3.ggpht.com/jpoehls/SBHc1vhLgAI/AAAAAAAABrA/ZTruHjg5OaY/15%5B5%5D.png"><img height="82" alt="15" src="http://lh4.ggpht.com/jpoehls/SBHc1_hLgBI/AAAAAAAABrE/oG57UOwxXRM/15_thumb%5B3%5D.png" width="400" /></a>      
</li>    <li>Beautiful. </li> </ol>  <h2>Footnotes</h2>  <p>Ok. So you’ve seen now how to generate new migrations and run them against your database. You’ve also seen how to migrate your database backwards and forwards using those scripts. Here are some misc notes I didn’t work in:</p>  <ul>   <li>The db.exe executable and config should be stored in source control right along with the /migrate folder and the migration scripts. Think of this exe as more of a script than an application. Its only job is to serve the migration scripts for this specific project.     
</li>    <li>When you tag (or Label in SourceSafe and TFS) your build, you will include all migration scripts that build uses. This means for any version of your application, you know <i>exactly</i> which version of the schema you need to migrate to. Since all migrations are incremental, building on the previous ones, this means you will always be able to create an instance of your database schema to match every build of your application.      
</li>    <li>I didn’t demo it here, but DotNetMigrations does everything it can to protect your existing schema. When you run the migrate command, all setup/teardown scripts are wrapped in a transaction and executed as one block. If any part of any of the scripts fail, then the whole transaction will be rolled back and <i>no change</i> will be made to your database. Of course we all test our scripts thoroughly right?      
</li>    <li>You don’t have to under-score the names of your migrations, you could just as easily use CamelCasing, but let’s stay away from spaces, please. </li> </ul>  <h2>TIPS &amp; TRICKS for using migrations on an existing database</h2>  <h2></h2>  <ul>   <li>So you have an existing database and want to start using migrations? Easy. Generate a migration script and call it <b>initial_setup</b> or whatever makes sense.      
</li>    <li>Use SQL Studio to generate the CREATE scripts for all objects in your database. Put those in the SETUP step of the migration.     
</li>    <li>Do the same to generate the DROP scripts and put those in the TEARDOWN.     
</li>    <li>TEST, TEST, TEST! Create a new, empty database and run your migration SETUP and TEARDOWN scripts against it. This is very important when creating the migration script for an existing database since all your tables, constraints, indexes, stored procs, etc. probably need to be created (and dropped) in a specific order so that no dependencies are broken.     
</li>    <li>Now that you have your <b>001_initial_setup</b> migration you can start using migrations for all your incremental database changes. Go for it! </li> </ul>  